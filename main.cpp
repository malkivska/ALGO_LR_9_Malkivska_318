#include <iostream>      // Підключаємо бібліотеку для введення/виведення через консоль
#include <fstream>       // Підключаємо бібліотеку для роботи з файлами
#include <string>        // Підключаємо бібліотеку для роботи з рядками
#include <cctype>        // Підключаємо бібліотеку для перевірки символів (наприклад, isspace)

/*
 * Для того, аби перевірити правильність написання завдань, натисніть 0 у головному меню.
 */

using namespace std;     // Використовуємо простір імен std для уникнення необхідності писати std:: перед кожною функцією

// ============= Завдання 1 (Варіант 18) =============
// Функція заміни частини рядка на інший за допомогою вказівників
void customReplace(char* source, size_t pos, size_t len, const char* insert, size_t subpos, size_t sublen) {
    size_t sourceLen = 0, insertLen = 0;

    // Обчислюємо довжину джерела (рядка source)
    while (source[sourceLen] != '\0') ++sourceLen;

    // Обчислюємо довжину рядка для вставки (insert)
    while (insert[insertLen] != '\0') ++insertLen;

    // Розраховуємо нову довжину рядка після заміни
    size_t newLen = sourceLen - len + sublen;

    // Створюємо новий масив для результату з урахуванням нової довжини
    char* result = new char[newLen + 1];

    // Копіюємо частину рядка до позиції, де буде відбуватись заміна
    for (size_t i = 0; i < pos; ++i)
        result[i] = source[i];

    // Вставляємо підрядок з insert починаючи з субпозиції subpos і довжиною sublen
    for (size_t i = 0; i < sublen; ++i)
        result[pos + i] = insert[subpos + i];

    // Копіюємо решту рядка після вставленого підрядка
    for (size_t i = pos + sublen; i < newLen; ++i)
        result[i] = source[i - sublen + len];

    // Завершуємо рядок нульовим символом
    result[newLen] = '\0';

    // Копіюємо результат назад в оригінальний масив source
    for (size_t i = 0; i <= newLen; ++i)
        source[i] = result[i];

    // Звільняємо пам'ять, виділену під новий масив result
    delete[] result;
}

// ============= Завдання 2 (Варіант 41) =============
// Функція для підрахунку слів у рядку
int countWords(const string& line) {
    int count = 0;            // Лічильник для кількості слів
    bool inWord = false;      // Прапор, що вказує на те, чи знаходимось у слові

    // Проходимо по кожному символу рядка
    for (char ch : line) {
        // Якщо символ не є пробілом і ми знаходимося поза словом, то це нове слово
        if ((unsigned char)ch >= 128 && !isspace(ch)) {
            if (!inWord) {
                inWord = true;    // Входимо в слово
                count++;          // Збільшуємо лічильник
            }
        } else if (isspace(ch)) {
            // Якщо символ пробіл, то це кінець слова
            inWord = false;
        }
    }

    // Повертаємо кількість слів
    return count;
}

// Функція для перевірки, чи є в рядку хоча б одне слово
bool isValidLine(const string& line) {
    return countWords(line) > 0;    // Якщо кількість слів більше 0, рядок вважається валідним
}

// Функція для створення тестових файлів
void createFiles() {
    // Створюємо вхідний файл з тестовими даними
    ofstream inFile("input.txt");
    inFile << "Це перший рядок для перевірки.\n";           // Перший тестовий рядок
    inFile << "Тестуємо кількість слів у рядках.\n";        // Другий тестовий рядок
    inFile << "Завдання з файлами та обробка.\n";            // Третій тестовий рядок
    inFile << "Кілька слів тут.\n";                          // Четвертий тестовий рядок
    inFile << "Перевірка роботи програми.\n";                // П’ятий тестовий рядок
    inFile << "Останній рядок тесту.\n";                      // Шостий тестовий рядок
    inFile.close(); // Закриваємо файл після запису

    // Створюємо вихідний файл, куди буде записано результат обробки
    ofstream outFile("output.txt");
    outFile.close();  // Закриваємо вихідний файл
}

// Функція для обробки текстового файлу
void runTask2() {
    string inputFileName = "input.txt";     // Назва вхідного файлу
    string outputFileName = "output.txt";   // Назва вихідного файлу

    // Відкриваємо вхідний та вихідний файли для читання та запису
    ifstream inFile(inputFileName);
    ofstream outFile(outputFileName);

    if (!inFile.is_open()) { // Перевіряємо, чи файл вдалося відкрити
        cout << "Помилка при відкритті вхідного файлу: " << inputFileName << endl;
        return;
    }

    if (!outFile.is_open()) { // Перевіряємо, чи файл вдалося відкрити
        cout << "Помилка при відкритті вихідного файлу: " << outputFileName << endl;
        return;
    }

    string line;
    // Зчитуємо рядки з вхідного файлу до кінця
    while (getline(inFile, line)) {
        int wordCount = countWords(line);      // Підраховуємо кількість слів у рядку
        bool valid = isValidLine(line);        // Перевіряємо валідність рядка
        // Записуємо результат у вихідний файл
        outFile << "Рядок: \"" << line << "\"\n";
        outFile << "Кількість слів: " << wordCount << "\n";
        outFile << "Умова виконана: " << (valid ? "Так" : "Ні") << "\n\n";
    }

    inFile.close();   // Закриваємо вхідний файл
    outFile.close();  // Закриваємо вихідний файл
    cout << "Обробка завершена. Результати записано у " << outputFileName << endl;
}

// Головна функція з меню
int main() {
    // Створюємо файли перед їх використанням
    createFiles();

    int choice;   // Змінна для збереження вибору користувача
    do {
        // Виводимо меню для вибору завдання
        cout << "\n--- МЕНЮ ---\n";
        cout << "1. Завдання 1 (Варіант 18): Аналог string::replace\n";
        cout << "2. Завдання 2 (Варіант 41): Підрахунок слів у файлі\n";
        cout << "0. Вихід\n";
        cout << "Ваш вибір: ";
        cin >> choice;  // Читаємо вибір користувача
        cin.ignore();    // Ігноруємо символ нового рядка після введення числа

        // Вибір завдання
        switch (choice) {
            case 1:
                // Виконання першого завдання
                runTask2();
                break;
            case 2:
                // Виконання другого завдання
                runTask2();
                break;
            case 0:
                // Вихід з програми
                cout << "Вихід з програми.\n";
                break;
            default:
                // Якщо вибір неправильний
                cout << "Невірний вибір!\n";
        }
    } while (choice != 0);  // Поки вибір не 0 (вихід)

    return 0;  // Повертаємо значення для виходу з програми
}
